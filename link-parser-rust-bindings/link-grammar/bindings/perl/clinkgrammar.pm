# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.0.2
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

package clinkgrammar;
use base qw(Exporter);
use base qw(DynaLoader);
package clinkgrammarc;
bootstrap clinkgrammar;
package clinkgrammar;
@EXPORT = qw();

# ---------- BASE METHODS -------------

package clinkgrammar;

sub TIEHASH {
    my ($classname,$obj) = @_;
    return bless $obj, $classname;
}

sub CLEAR { }

sub FIRSTKEY { }

sub NEXTKEY { }

sub FETCH {
    my ($self,$field) = @_;
    my $member_func = "swig_${field}_get";
    $self->$member_func();
}

sub STORE {
    my ($self,$field,$newval) = @_;
    my $member_func = "swig_${field}_set";
    $self->$member_func($newval);
}

sub this {
    my $ptr = shift;
    return tied(%$ptr);
}


# ------- FUNCTION WRAPPERS --------

package clinkgrammar;

*lg_exp_resolve = *clinkgrammarc::lg_exp_resolve;
*linkgrammar_get_version = *clinkgrammarc::linkgrammar_get_version;
*linkgrammar_get_dict_version = *clinkgrammarc::linkgrammar_get_dict_version;
*linkgrammar_get_configuration = *clinkgrammarc::linkgrammar_get_configuration;
*linkgrammar_get_dict_locale = *clinkgrammarc::linkgrammar_get_dict_locale;
*linkgrammar_get_dict_max_disjunct_cost = *clinkgrammarc::linkgrammar_get_dict_max_disjunct_cost;
*linkgrammar_get_dict_define = *clinkgrammarc::linkgrammar_get_dict_define;
*lg_error_set_handler = *clinkgrammarc::lg_error_set_handler;
*_lg_error_formatmsg = *clinkgrammarc::_lg_error_formatmsg;
*lg_error_printall = *clinkgrammarc::lg_error_printall;
*lg_error_clearall = *clinkgrammarc::lg_error_clearall;
*lg_error_flush = *clinkgrammarc::lg_error_flush;
*dictionary_create_lang = *clinkgrammarc::dictionary_create_lang;
*dictionary_get_lang = *clinkgrammarc::dictionary_get_lang;
*dictionary_delete = *clinkgrammarc::dictionary_delete;
*dictionary_set_data_dir = *clinkgrammarc::dictionary_set_data_dir;
*dictionary_get_data_dir = *clinkgrammarc::dictionary_get_data_dir;
*linkgrammar_open_data_file = *clinkgrammarc::linkgrammar_open_data_file;
*parse_options_create = *clinkgrammarc::parse_options_create;
*parse_options_delete = *clinkgrammarc::parse_options_delete;
*parse_options_set_verbosity = *clinkgrammarc::parse_options_set_verbosity;
*parse_options_get_verbosity = *clinkgrammarc::parse_options_get_verbosity;
*parse_options_set_debug = *clinkgrammarc::parse_options_set_debug;
*parse_options_get_debug = *clinkgrammarc::parse_options_get_debug;
*parse_options_set_test = *clinkgrammarc::parse_options_set_test;
*parse_options_get_test = *clinkgrammarc::parse_options_get_test;
*parse_options_set_linkage_limit = *clinkgrammarc::parse_options_set_linkage_limit;
*parse_options_get_linkage_limit = *clinkgrammarc::parse_options_get_linkage_limit;
*parse_options_set_disjunct_cost = *clinkgrammarc::parse_options_set_disjunct_cost;
*parse_options_get_disjunct_cost = *clinkgrammarc::parse_options_get_disjunct_cost;
*parse_options_set_min_null_count = *clinkgrammarc::parse_options_set_min_null_count;
*parse_options_get_min_null_count = *clinkgrammarc::parse_options_get_min_null_count;
*parse_options_set_max_null_count = *clinkgrammarc::parse_options_set_max_null_count;
*parse_options_get_max_null_count = *clinkgrammarc::parse_options_get_max_null_count;
*parse_options_set_islands_ok = *clinkgrammarc::parse_options_set_islands_ok;
*parse_options_get_islands_ok = *clinkgrammarc::parse_options_get_islands_ok;
*parse_options_set_spell_guess = *clinkgrammarc::parse_options_set_spell_guess;
*parse_options_get_spell_guess = *clinkgrammarc::parse_options_get_spell_guess;
*parse_options_set_short_length = *clinkgrammarc::parse_options_set_short_length;
*parse_options_get_short_length = *clinkgrammarc::parse_options_get_short_length;
*parse_options_set_max_parse_time = *clinkgrammarc::parse_options_set_max_parse_time;
*parse_options_get_max_parse_time = *clinkgrammarc::parse_options_get_max_parse_time;
*parse_options_set_cost_model_type = *clinkgrammarc::parse_options_set_cost_model_type;
*parse_options_get_cost_model_type = *clinkgrammarc::parse_options_get_cost_model_type;
*parse_options_set_perform_pp_prune = *clinkgrammarc::parse_options_set_perform_pp_prune;
*parse_options_get_perform_pp_prune = *clinkgrammarc::parse_options_get_perform_pp_prune;
*parse_options_set_use_sat_parser = *clinkgrammarc::parse_options_set_use_sat_parser;
*parse_options_get_use_sat_parser = *clinkgrammarc::parse_options_get_use_sat_parser;
*parse_options_timer_expired = *clinkgrammarc::parse_options_timer_expired;
*parse_options_set_all_short_connectors = *clinkgrammarc::parse_options_set_all_short_connectors;
*parse_options_get_all_short_connectors = *clinkgrammarc::parse_options_get_all_short_connectors;
*parse_options_set_repeatable_rand = *clinkgrammarc::parse_options_set_repeatable_rand;
*parse_options_get_repeatable_rand = *clinkgrammarc::parse_options_get_repeatable_rand;
*parse_options_reset_resources = *clinkgrammarc::parse_options_reset_resources;
*parse_options_get_dialect = *clinkgrammarc::parse_options_get_dialect;
*parse_options_set_dialect = *clinkgrammarc::parse_options_set_dialect;
*parse_options_set_display_morphology = *clinkgrammarc::parse_options_set_display_morphology;
*parse_options_get_display_morphology = *clinkgrammarc::parse_options_get_display_morphology;
*sentence_create = *clinkgrammarc::sentence_create;
*sentence_delete = *clinkgrammarc::sentence_delete;
*sentence_split = *clinkgrammarc::sentence_split;
*sentence_parse = *clinkgrammarc::sentence_parse;
*sentence_length = *clinkgrammarc::sentence_length;
*sentence_null_count = *clinkgrammarc::sentence_null_count;
*sentence_num_linkages_found = *clinkgrammarc::sentence_num_linkages_found;
*sentence_num_valid_linkages = *clinkgrammarc::sentence_num_valid_linkages;
*sentence_num_linkages_post_processed = *clinkgrammarc::sentence_num_linkages_post_processed;
*sentence_num_violations = *clinkgrammarc::sentence_num_violations;
*sentence_disjunct_cost = *clinkgrammarc::sentence_disjunct_cost;
*sentence_link_cost = *clinkgrammarc::sentence_link_cost;
*sentence_display_wordgraph = *clinkgrammarc::sentence_display_wordgraph;
*linkage_create = *clinkgrammarc::linkage_create;
*linkage_delete = *clinkgrammarc::linkage_delete;
*linkage_get_num_words = *clinkgrammarc::linkage_get_num_words;
*linkage_get_num_links = *clinkgrammarc::linkage_get_num_links;
*linkage_get_link_lword = *clinkgrammarc::linkage_get_link_lword;
*linkage_get_link_rword = *clinkgrammarc::linkage_get_link_rword;
*linkage_get_link_length = *clinkgrammarc::linkage_get_link_length;
*linkage_get_link_label = *clinkgrammarc::linkage_get_link_label;
*linkage_get_link_llabel = *clinkgrammarc::linkage_get_link_llabel;
*linkage_get_link_rlabel = *clinkgrammarc::linkage_get_link_rlabel;
*linkage_get_link_num_domains = *clinkgrammarc::linkage_get_link_num_domains;
*linkage_get_link_domain_names = *clinkgrammarc::linkage_get_link_domain_names;
*linkage_get_words = *clinkgrammarc::linkage_get_words;
*linkage_get_disjunct_str = *clinkgrammarc::linkage_get_disjunct_str;
*linkage_get_disjunct_cost = *clinkgrammarc::linkage_get_disjunct_cost;
*linkage_get_word = *clinkgrammarc::linkage_get_word;
*linkage_print_constituent_tree = *clinkgrammarc::linkage_print_constituent_tree;
*linkage_free_constituent_tree_str = *clinkgrammarc::linkage_free_constituent_tree_str;
*linkage_print_diagram = *clinkgrammarc::linkage_print_diagram;
*linkage_free_diagram = *clinkgrammarc::linkage_free_diagram;
*linkage_print_postscript = *clinkgrammarc::linkage_print_postscript;
*linkage_free_postscript = *clinkgrammarc::linkage_free_postscript;
*linkage_print_disjuncts = *clinkgrammarc::linkage_print_disjuncts;
*linkage_free_disjuncts = *clinkgrammarc::linkage_free_disjuncts;
*linkage_print_links_and_domains = *clinkgrammarc::linkage_print_links_and_domains;
*linkage_free_links_and_domains = *clinkgrammarc::linkage_free_links_and_domains;
*linkage_print_pp_msgs = *clinkgrammarc::linkage_print_pp_msgs;
*linkage_free_pp_msgs = *clinkgrammarc::linkage_free_pp_msgs;
*linkage_unused_word_cost = *clinkgrammarc::linkage_unused_word_cost;
*linkage_disjunct_cost = *clinkgrammarc::linkage_disjunct_cost;
*linkage_link_cost = *clinkgrammarc::linkage_link_cost;
*linkage_get_violation_name = *clinkgrammarc::linkage_get_violation_name;
*linkage_get_word_byte_start = *clinkgrammarc::linkage_get_word_byte_start;
*linkage_get_word_byte_end = *clinkgrammarc::linkage_get_word_byte_end;
*linkage_get_word_char_start = *clinkgrammarc::linkage_get_word_char_start;
*linkage_get_word_char_end = *clinkgrammarc::linkage_get_word_char_end;
*utf8_strwidth = *clinkgrammarc::utf8_strwidth;
*dict_display_word_expr = *clinkgrammarc::dict_display_word_expr;
*dict_display_word_info = *clinkgrammarc::dict_display_word_info;
*parse_options_print_total_time = *clinkgrammarc::parse_options_print_total_time;
*_prt_error = *clinkgrammarc::_prt_error;
*dictionary_lookup_list = *clinkgrammarc::dictionary_lookup_list;
*dictionary_lookup_wild = *clinkgrammarc::dictionary_lookup_wild;
*free_lookup_list = *clinkgrammarc::free_lookup_list;
*dictionary_get_categories = *clinkgrammarc::dictionary_get_categories;
*linkage_get_categories = *clinkgrammarc::linkage_get_categories;
*sentence_unused_disjuncts = *clinkgrammarc::sentence_unused_disjuncts;
*disjunct_expression = *clinkgrammarc::disjunct_expression;
*disjunct_categories = *clinkgrammarc::disjunct_categories;
*dictionary_word_is_known = *clinkgrammarc::dictionary_word_is_known;
*lg_exp_get_type = *clinkgrammarc::lg_exp_get_type;
*lg_exp_get_dir = *clinkgrammarc::lg_exp_get_dir;
*lg_exp_get_multi = *clinkgrammarc::lg_exp_get_multi;
*lg_exp_get_cost = *clinkgrammarc::lg_exp_get_cost;
*lg_exp_operand_first = *clinkgrammarc::lg_exp_operand_first;
*lg_exp_operand_next = *clinkgrammarc::lg_exp_operand_next;
*lg_exp_get_string = *clinkgrammarc::lg_exp_get_string;
*lg_exp_stringify = *clinkgrammarc::lg_exp_stringify;

############# Class : clinkgrammar::Parse_Options ##############

package clinkgrammar::Parse_Options;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( clinkgrammar );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        clinkgrammarc::delete_Parse_Options($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : clinkgrammar::Exp ##############

package clinkgrammar::Exp;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( clinkgrammar );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        clinkgrammarc::delete_Exp($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : clinkgrammar::lg_errinfo ##############

package clinkgrammar::lg_errinfo;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( clinkgrammar );
%OWNER = ();
%ITERATORS = ();
*swig_severity_get = *clinkgrammarc::lg_errinfo_severity_get;
*swig_severity_set = *clinkgrammarc::lg_errinfo_severity_set;
*swig_severity_label_get = *clinkgrammarc::lg_errinfo_severity_label_get;
*swig_severity_label_set = *clinkgrammarc::lg_errinfo_severity_label_set;
*swig_text_get = *clinkgrammarc::lg_errinfo_text_get;
*swig_text_set = *clinkgrammarc::lg_errinfo_text_set;
sub new {
    my $pkg = shift;
    my $self = clinkgrammarc::new_lg_errinfo(@_);
    bless $self, $pkg if defined($self);
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : clinkgrammar::Category ##############

package clinkgrammar::Category;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( clinkgrammar );
%OWNER = ();
%ITERATORS = ();
*swig_num_words_get = *clinkgrammarc::Category_num_words_get;
*swig_num_words_set = *clinkgrammarc::Category_num_words_set;
*swig_name_get = *clinkgrammarc::Category_name_get;
*swig_name_set = *clinkgrammarc::Category_name_set;
*swig_exp_get = *clinkgrammarc::Category_exp_get;
*swig_exp_set = *clinkgrammarc::Category_exp_set;
*swig_word_get = *clinkgrammarc::Category_word_get;
*swig_word_set = *clinkgrammarc::Category_word_set;
sub new {
    my $pkg = shift;
    my $self = clinkgrammarc::new_Category(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        clinkgrammarc::delete_Category($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : clinkgrammar::Category_cost ##############

package clinkgrammar::Category_cost;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( clinkgrammar );
%OWNER = ();
%ITERATORS = ();
*swig_num_get = *clinkgrammarc::Category_cost_num_get;
*swig_num_set = *clinkgrammarc::Category_cost_num_set;
*swig_cost_get = *clinkgrammarc::Category_cost_cost_get;
*swig_cost_set = *clinkgrammarc::Category_cost_cost_set;
sub new {
    my $pkg = shift;
    my $self = clinkgrammarc::new_Category_cost(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        clinkgrammarc::delete_Category_cost($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : clinkgrammar::Dict_node_struct ##############

package clinkgrammar::Dict_node_struct;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( clinkgrammar );
%OWNER = ();
%ITERATORS = ();
*swig_string_get = *clinkgrammarc::Dict_node_struct_string_get;
*swig_string_set = *clinkgrammarc::Dict_node_struct_string_set;
*swig_file_get = *clinkgrammarc::Dict_node_struct_file_get;
*swig_file_set = *clinkgrammarc::Dict_node_struct_file_set;
*swig_exp_get = *clinkgrammarc::Dict_node_struct_exp_get;
*swig_exp_set = *clinkgrammarc::Dict_node_struct_exp_set;
sub new {
    my $pkg = shift;
    my $self = clinkgrammarc::new_Dict_node_struct(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        clinkgrammarc::delete_Dict_node_struct($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


# ------- VARIABLE STUBS --------

package clinkgrammar;

*LG_PANIC_DISJUNCT_COST = *clinkgrammarc::LG_PANIC_DISJUNCT_COST;
*lg_Fatal = *clinkgrammarc::lg_Fatal;
*lg_Error = *clinkgrammarc::lg_Error;
*lg_Warn = *clinkgrammarc::lg_Warn;
*lg_Info = *clinkgrammarc::lg_Info;
*lg_Debug = *clinkgrammarc::lg_Debug;
*lg_Trace = *clinkgrammarc::lg_Trace;
*lg_None = *clinkgrammarc::lg_None;
*VDAL = *clinkgrammarc::VDAL;
*NO_DISPLAY = *clinkgrammarc::NO_DISPLAY;
*MULTILINE = *clinkgrammarc::MULTILINE;
*BRACKET_TREE = *clinkgrammarc::BRACKET_TREE;
*SINGLE_LINE = *clinkgrammarc::SINGLE_LINE;
*MAX_STYLES = *clinkgrammarc::MAX_STYLES;
*LEFT_WALL_WORD = *clinkgrammarc::LEFT_WALL_WORD;
*RIGHT_WALL_WORD = *clinkgrammarc::RIGHT_WALL_WORD;
*UNKNOWN_WORD = *clinkgrammarc::UNKNOWN_WORD;
*WILDCARD_WORD = *clinkgrammarc::WILDCARD_WORD;
*MAX_WORD = *clinkgrammarc::MAX_WORD;
*SUBSCRIPT_MARK = *clinkgrammarc::SUBSCRIPT_MARK;
*SUBSCRIPT_DOT = *clinkgrammarc::SUBSCRIPT_DOT;
*OR_type = *clinkgrammarc::OR_type;
*AND_type = *clinkgrammarc::AND_type;
*CONNECTOR_type = *clinkgrammarc::CONNECTOR_type;
1;
